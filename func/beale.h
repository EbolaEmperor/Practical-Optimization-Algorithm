#ifndef _BEALE_
#define _BEALE_

#include "../lib/matrix.h"

namespace beale{

double f(const Matrix & x)
// 返回f在x处的函数值
{
    return (1.5-x[0][0]+x[0][0]*x[1][0])*(1.5-x[0][0]+x[0][0]*x[1][0]) + 
           (2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0])*(2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0]) +
           (2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0])*(2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0]);
}

Matrix grad(const Matrix & x)
// 返回f在x处的梯度向量
{
    Matrix g(2,1);
    g[0][0] = 2*(x[1][0]-1)*(1.5-x[0][0]+x[0][0]*x[1][0]) + 
              2*(x[1][0]*x[1][0]-1)*(2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0]) +
              2*(x[1][0]*x[1][0]*x[1][0]-1)*(2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0]);
    g[1][0] = 2*x[0][0]*(1.5-x[0][0]+x[0][0]*x[1][0]) + 
              4*x[0][0]*x[1][0]*(2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0]) +
              6*x[0][0]*x[1][0]*x[1][0]*(2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0]);
    return g;
}

Matrix hessian(const Matrix &x)
// 返回f在x处的Hessian矩阵
{
    Matrix h(2,2);
    h[0][0] = (2*(x[1][0]-1)*(x[1][0]-1) + 
              2*(x[1][0]*x[1][0]-1)*(x[1][0]*x[1][0]-1) +
              2*(x[1][0]*x[1][0]*x[1][0]-1)*(x[1][0]*x[1][0]*x[1][0]-1));
    h[0][1] = h[1][0] = (2*(1.5-x[0][0]+x[0][0]*x[1][0]) + 2*x[0][0]*(x[1][0]-1) +
                        4*x[1][0]*(2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0]) + 4*x[0][0]*x[1][0]*(x[1][0]*x[1][0]-1) +
                        6*x[1][0]*x[1][0]*(2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0]) + 6*x[0][0]*x[1][0]*x[1][0]*(x[1][0]*x[1][0]*x[1][0]-1));
    h[1][1] = (2*x[0][0]*x[0][0] + 
              4*x[0][0]*(2.25-x[0][0]+x[0][0]*x[1][0]*x[1][0]) + 8*x[0][0]*x[0][0]*x[1][0]*x[1][0] + 
              12*x[0][0]*x[1][0]*(2.625-x[0][0]+x[0][0]*x[1][0]*x[1][0]*x[1][0]) + 18*x[0][0]*x[0][0]*x[1][0]*x[1][0]*x[1][0]*x[1][0]);
    return h;
}

Matrix initial(){
    Matrix x(2,1);
    x[0][0] = -1.2;
    x[1][0] = 1;
    return x;
}

}

#endif