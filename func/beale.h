#ifndef _BEALE_
#define _BEALE_

#include "../lib/matrix.h"

namespace beale{

double f(const ColVector & x)
// 返回f在x处的函数值
{
    return (1.5-x[0]+x[0]*x[1])*(1.5-x[0]+x[0]*x[1]) + 
           (2.25-x[0]+x[0]*x[1]*x[1])*(2.25-x[0]+x[0]*x[1]*x[1]) +
           (2.625-x[0]+x[0]*x[1]*x[1]*x[1])*(2.625-x[0]+x[0]*x[1]*x[1]*x[1]);
}

ColVector grad(const ColVector & x)
// 返回f在x处的梯度向量
{
    ColVector g(2);
    g[0] = 2*(x[1]-1)*(1.5-x[0]+x[0]*x[1]) + 
           2*(x[1]*x[1]-1)*(2.25-x[0]+x[0]*x[1]*x[1]) +
           2*(x[1]*x[1]*x[1]-1)*(2.625-x[0]+x[0]*x[1]*x[1]*x[1]);
    g[1] = 2*x[0]*(1.5-x[0]+x[0]*x[1]) + 
           4*x[0]*x[1]*(2.25-x[0]+x[0]*x[1]*x[1]) +
           6*x[0]*x[1]*x[1]*(2.625-x[0]+x[0]*x[1]*x[1]*x[1]);
    return g;
}

Matrix hessian(const ColVector &x)
// 返回f在x处的Hessian矩阵
{
    Matrix h(2,2);
    h[0][0] = (2*(x[1]-1)*(x[1]-1) + 
              2*(x[1]*x[1]-1)*(x[1]*x[1]-1) +
              2*(x[1]*x[1]*x[1]-1)*(x[1]*x[1]*x[1]-1));
    h[0][1] = h[1][0] = (2*(1.5-x[0]+x[0]*x[1]) + 2*x[0]*(x[1]-1) +
                        4*x[1]*(2.25-x[0]+x[0]*x[1]*x[1]) + 4*x[0]*x[1]*(x[1]*x[1]-1) +
                        6*x[1]*x[1]*(2.625-x[0]+x[0]*x[1]*x[1]*x[1]) + 6*x[0]*x[1]*x[1]*(x[1]*x[1]*x[1]-1));
    h[1][1] = (2*x[0]*x[0] + 
              4*x[0]*(2.25-x[0]+x[0]*x[1]*x[1]) + 8*x[0]*x[0]*x[1]*x[1] + 
              12*x[0]*x[1]*(2.625-x[0]+x[0]*x[1]*x[1]*x[1]) + 18*x[0]*x[0]*x[1]*x[1]*x[1]*x[1]);
    return h;
}

ColVector initial(){
    ColVector x(2);
    x[0] = -1.2;
    x[1] = 1;
    return x;
}

}

#endif